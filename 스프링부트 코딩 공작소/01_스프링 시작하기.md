# 1.1 스프링의 새로운 시작

스프링은 JEE나 J2EE로 알려진 자바 엔터프라이즈 에디션을 경량화 하려는 대안으로 시작했었다.
스프링은 무거운 엔터프라이즈 자바빈으로 컴포넌트를 개발하지 않았다. 그대신 **의존성 주입**과 **관점 지향 프로그래밍**을 활용하여 EJB의 기능을 평벙함 자바객체(POJO)로 구현할 수 있게 하여 간단하게 엔터프라이즈 자바 개발에 접근할 수 있는 방법을 제공했다.

모든 구성 작업은 개발 저항으로 나타난다. 애플리케이션 로직 작성 대신 구성 작업에 쓰는 시간은 모두 낭비다. 스프링 기능 구성에 정신이 팔리면 비즈니스 문제를 해결하는 데 방해가 된다.

의존성 관리는 중요한 문제이지만, 또 다른 저항이 된다. 의존 라이브 러리의 버전을 잘못 서낵하여 발생하는 모든 호환성 문제는 생산성을 망치는 주범이나, 스프링 부트는 이것을 모두 바꾸어 놓았다.

## 1.1.1 스프링의 새로운 모습 살펴보기

- 필요한 의존성을 비롯한 `maven`이나 `gradle` 빌드 파일이 완비된 프로젝트 구조.
- 스프링의 `DispatcherServelet을` 선언한 `web.xml` 파일 또는 `WebApplicationInitializer` 구현
- 스프링 MVC를 사용할 수 있는 스프링 구성
- HTTP 요청에 "Hello World"라고 응답할 컨트롤러 클래스
- 애플리케이션을 배포할 웹 애플리케이션 서버(톰캣 등)

이 목록에서 필요한건 **컨트롤러** 하나 뿐이다. 나머지 항목은 스프링으로 Web Application을 개발할때 필요한 일반적인 보일러 플레이트이다.

상기의 애플리케이션을 실행하는 복잡한 과정은 스프링 부트가 처리한다.

## 1.1.2 스프링 부트의 핵심 살펴보기

1. **자동 구성**  
   많은 스프링 애플리케이션에 공통으로 필요한 애플리케이션 기능을 자동으로 구성한다.
2. **스타터 의존성**  
   스프링 부트에 어떤 기능이 필요한지 알려 주면 필요한 라이브러리를 빌드에 추가한다는것을 보장한다.
3. **명령줄 인터페이스**  
   스프링 부트의 이 부가기능을 이용하면 애플리케이션 코드만 작성해도 완전한 애플리케이션을 개발할 수 있지만, 기존 프로젝트 빌드방식에는 필요없는 기능이다.
4. **액추에이터**  
   스프링 부트 애플리케이션을 실행할 때 내부에서 어떤 일이 일어나는지 이해 할 수 있다.

### 1.1.2.1 자동구성

예를 들어 JDBC로 관계형 데이터 베이스에 접속하는 애플리케이션을 작성해야 한다면 스프링 애플리케이션 컨텍스트에 `JdbcTemplate`를 빈으로 구성했을 것이다.

```java
@Bean
public JdbcTemplate jdbcTemplate(DataSource dataSource) {
   return new JdbcTemplate(dataSource);
}
```

간단한 빈 선언으로 `JdbcTemplate` 인스턴스를 생성하여 `DataSource` 의존성을 주입한다.

해당 DataSource를 내장 H2 데이터베이스로 구성했다고 가정하자.

```java
@Bean
public DataSource dataSource() {
   return new EmbeddedDatabaseBuilder()
      .setType(EmbeddedDatabaseType.H2)
      .addScripts('schema.sql', 'data.sql')
      .build();
}
```

위와 같은 예제와 완전히 메서드가 동일한 스프링 애플리케이션이 수도 없이 많을것이다. **즉, 보일러플레이트 구성이다.**

**굳이 새로 작성할 필요 없이 스프링 부트는 이런 공통 구성 시나리오르 자동으로 구성할 수 있다.** 스프링 부트에는 내장 데이터베이스와 JdbcTemplate등 많은 자동 구성이 있다.

### 1.1.2.2 스타터 의존성

**스프링 부트는 스타터 으존성 수단으로 프로젝트 의존성을 쉽게 관리한다.**

예를 들어 `JSON` 형식의 리소스를 다루는 `REST API`를 `스프링 MVC`로 만든다고 가정하면 메이븐이나 그레이들 빌드에 최소한 의존성을 여덟 개는 추가해야 한다.

```
org.springfrmaework:spring-core
org.springfrmaework:spring-web
org.springfrmaework:spring-webmvc
com.fasterxml.jackson.core:jackson-databind
org.hibernate:hibernate-validator
org.apache.tomcat.embed:tomcat-embed-core
org.apache.tomcat.embed:tomcat-embed-el
org.apache.tomcat.embed:tomcat-embed-logging-juli
```

반면 스프링 부트의 스타터 의존성을 사용하면 `스프링 부트 '웹' 스타터(org.springframework.boot:spring-boot-starter-web)`을 빌드 의존성으로 간단히 추가할 수 있다.

**특정 기능을 지원하려면 어떤 라이브러리를 사용해야 하는지 더는 생각할 필요가 없다. 그저 해당 기능에 적절한 스타터 의존성을 찾아서 요청하면 된다. 또한 스프링 부트의 스타터 의존성을 사용하면 필요한 라이브러리의 버전을 고민할 필요가 없다.**

### 1.1.2.3 명령줄 인터페이스

스프링 부트 CLI(명령줄 인터페이스)는 애플리케이션 코드만 작성해도 애플리케이션을 개발할 수 있다.

스프링 부트 CLI는 개발자가 코드 작성에만 집중할 수 있도록 스타터 의존성과 자동 구성을 활용한다.

```groovy
// 그루비로 작성한 완전한 스프링 애플리케이션
@RestController
class HelloController {
   @RequestMapping("/")
   def hello() {
      return "Hello World"
   }
}
```

`import`문도 없고, `RequestMapping`과 `RestController`의 패키지를 어떻게 알수 있었을까? 결론적으로 이 클래스들은 어떻게 클래스 패스에 있었을까?
`스프링 부트 CLI` 가 어떤 타입을 사용했는지 발견하여 이 타입이 작동할 수 있게 클래스 패스에 알맞은 스타터 의존성을 추가하기 때문이다.

### 1.1.2.4 액추에이터

작동 중인 애플리케이션의 내부를 살펴볼 수 있는 기능을 제공한다. 다음 애플리케이션의 내부 작동을 살펴볼 수 있다.

- 스프링 애플리케이션 컨텍스트에 구성된 빈
- 스프링 부트의 자동 구성으로 구성된 것
- 애플리케이션에서 사용할 수 있는 환경 변수, 시스템 프로퍼티, 구성 프로퍼티, 명령줄 인자
- 애플리케이션에서 구동 중인 스레드의 현재 상태
- 최근에 처리된 HTTP 요청 정보
- 메모리 사용량, 가비지 컬렉션, 웹 요청, 데이터 소스 사용량 등 다양한 메트릭

**엑추에이터는 이 정보를 웹 엔드포인트와 셸 인터페이스를 사용하여 보여준다.**

## 1.2.2 스프링 프로젝트 구성

스프링 부트 CLI도 있지만 전통적인 자바 프로젝트 구조가 더 마음에 든다면 `Spring Initializr`를 살펴보는 것도 좋다.

`Spring Initializr`는 스프링 부트 프로젝트 구조를 만드는 웹 애플리케이션이다. 기본적인 프로젝트 구조와 코드를 빌드하는 데 필요한 메이븐이나 그레이들 빌드 명세를 만들어 주어 해당 프로젝트에 애플리케이션 코드만 작성하면 된다.

다음 방법들로 Spring Initializr를 사용할 수 있다.

- 웹 기반 인터페이스
- Spring Toll Suite(STS)
- IntelliJ IDEA
- 스프링 부트 CLI

해당 프로젝트로 만들어진 파일은 다음과 같다.

- build.gradle  
  그레이들 빌드 명세. 메이븐 프로젝트를 선택했다면 `pom.xml로 대체됨
- gradlew  
  그레이들 래퍼. 시스템에 그레이들 미 설치시 `gradle 명령 대신에 이 스크립트를 사용
- MyappApplication.java  
  애플리케이션을 시작하는 `main()` 메서드가 있는 클래스
- application.propertise
  필요한 구성 프로퍼티를 추가하는 빈 프로퍼티 파일
- MyappApplicaionTest.java
  스프링 부트 자동 구성을 이용하여 스프링 애플리케이션 컨텍스트를 로드하도록 구성한 빈 JUnit 테스트 클래스

빈 디렉터리들도 의미가 있다.

- static 디렉터리  `
  웹 애플리케이션에서 제공할 자바스크립트, 스타일시트, 이미지를 비롯한 여러 정적 콘텐츠를 넣을 수 있다.
- templates 디렉터리  
  모델 데이터를 렌더링 할 템플릿을 넣는 곳

# 1.3 요약

스프링 부트는 프레임어크 자체에 저항을 최소화 하면서 스프링 애플리케이션을 개발할 수 있도록 한다. 
자동구성은 전통적인 스프링에 있던 많은 보일러 플레이트 구성을 제거했다.
스프링 부트 스타터는 명시적인 라이브러리 이름이나 버전 대신에 스프링 부트가 제공하는 기능으로 빌드 의존성을 지정할 수 있게 했다.
스프링 부트 CLI는 명령줄에서 그루비를 사용하여 빠르고 간편하게 개발할 수 있게 하였다.
액추에이터는 작동중인 애플리케이션 내부를 살펴보면서 스프링 부트가 어떤식으로 처리하는지 알 수 있게 했다.
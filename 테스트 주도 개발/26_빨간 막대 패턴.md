### 한 단계 테스트

Q. 다음 테스트를 고를 때 무엇을 기준으로 할 것인가?
A. 새로운 무언가를 가르쳐 줄 수 있으며, 구현할 수 있다는 확신이 드는 테스트를 고를 것.

뻔하지 않지만 구현할 수 있다는 확신이 있는 테스트를 바로 다음으로 구현할 테스트로 정해라.

전체 계산 중 간단한 하나의 사례를 나타내는 테스트에서 시작했다면, 이 테스트를 통해 자라는 프로그램은 `하향식(top-down)`으로 작성된 것으로 보일 수 있다.  
반면 전체의 작은 한 조각을 나타내는 테스트에서 시작하여 조금씩 붙여나가는 식이었다면, 이 프로그램은 `상향식(bottom-up)`으로 작성된 것으로 보일 수도 있다.

사실 `상향식`, `하향식` 둘 다 TDD의 프로세스를 효과적으로 설명해 줄 수 없다. 이와 같은 수직적 메타포는 시간에 따라 어떻게 변해 가는지에 대한 단순화 된 시각일 뿐이다.

**이보다 `성장` 이라는 단어를 보자.**

`성장`은 자기 유사성을 가진 피드백 고리를 암시하는데, 이 피드백 고리에서는 환경이 프로그램에 영향을 주고 프로그램이 다시 환경에 영향을 준다.

**만약 메타포가 어떤 방향성을 가질 필요가 있다면 `아는 것에서 모르는 것으로(known-to-unknown)` 라는 방향이 유용할 것이다.**

우리가 어느 정도의 지식과 경험을 가지고 개발을 시작한다는 점, 개발 하는 중에 새로운 것을 배우게 될 것임을 예상한다는 점 등을 암시한다.

**이 두가지를 합쳐보면 우리는 `아는 것에서 모르는 것으로 성장하는 프로그램`을 갖게 된다.`**

### 시작 테스트

Q. 어떤 테스트부터 시작하는게 좋을까?
A. 오퍼레이션이 아무 일도 하지 않는 경우를 먼저 테스트 할 것.

`이 오퍼레이션을 어디에 넣어야 하지?`

한번에 한 문제만 해결하자는 의미에서 이 질문만 생각할 방법은 현실적인 테스트를 하나 작성하는 것이다.

1. 이 오퍼레이션을 어디에 두어야하나?
2. 적절한 입력 값을 무엇인가?
3. 이 입력들이 주어졌을 때 적절한 출력은 무엇인가?

많은 문제들이 생겨났다. 포괄적인 하나의 테스트로 시작하면 오랫동안 피드백을 받지 못할것이다.

`빨강/초록/리팩토링`을 몇분이내로 반복하도록 하자. 정말 발견하기 쉬운 입력과 출력을 사용하면 이 시간을 짧게 줄일 수 있다.

다각형 축소기를 테스트 우선으로 작성하려고 한다. 입력은 다각형 그물이고, 출력은 정확하게 똑같은 표면이면서 가능한 한 최소 개수의 다각형으로 구성된 다각형 그물이 된다.

- 출력이 입력과 같은 경우가 있다. 어떤 형상의 다각형들은 이미 정규화되어있고 더 축소할 수 없다.
- 입력은 가능한 한 적어야한다. 이를테면 다각형 하나 또는 아예 비어있는 다각형 목록일 수도 있다.

```java
Reducer r = new Reducer(new Polygon());
assertEquals(0, reducer.result().npoints);
```

다음과 같은 시작 테스트를 작성했고 잘 돌아간다. 이제 목록에 있는 나머지 테스트를 처리 하면 된다.

만약 당신이 어떤 애플리케이션을 n번째 구현하고 있다면, 오퍼레이션을 한두개 필요로 하는 테스트를 하나 골라라.

저자가 자구 테스트 주도로 개발하는 예 중 하나는 간단한 소켓 기반 서버라고 한다.

```java
StartServer
Socket= new Socket
Message= "hello"
Socket.write(message)
AssertEquals(message, socket.read)
```

이제 나머지 테스트는 서버만으로 이루어 질 수 있다. "우리가 이런 문자열을 받았다고 치고..."

### 설명 테스트

자동화된 테스트가 더 널리 쓰이게 하려면 테스트를 통해 설명을 요청하고 테스트를 통해 설명하라.

팀에서 혼자 TDD를 한다면 꽤나 어려움을 느낄 수 있지만 머지않아 테스트된 코드의 통합 문제와 결함 보고가 줄어든느 것을 팀에서 알아챌 것이고, 설계는 더 단순해지고 설명하기에 용이해질 것이다.

새로 전향한 사람들의 열의를 조심하라. 사람들에게 TDD를 쓰라고 강요할때마다 TDD가 퍼지는것을 빨리 막게 될 것이다. 사람들이 일하는 방식을 강제로 바꿀 수는 없다.

단순한 시작법은 테스트를 이용하여 묻고, 테스트를 이용하여 설명하는 것이다. 예를 들어 `"Foo를 이런식으로 설정하고 Bar를 이런식으로 설정하면 76이 나와야하는거죠?"`라고 묻고, `"Foo를 이런식으로 설정하고 Bar를 이런식으로 설정하면 76이 나와야 됩니다. 그리고 Foo가 이렇고 Bar가 이러면 67이 나오겠죠"` 라고 설명하는것이다.

더 추상적인 방법은 시퀀스 다이어그램에 나타난 모든 요소들을 포함하는 테스트 케이스를 작성해 보는것이다.

### 학습 테스트

외부에서 만든 소프트웨어에 대한 테스트를 작성해야 할 때도 있다.

외부와 연동할 때 새 클래스의 새 메서드를 하나 사용한다는 것을 알아채자. 그냥 바로 사용하는 대신 API가 우리 예상대로 실행된다는 것을 확인해줄 만한 작은 테스트를 만들어 보는 것이다.

```java
public void setUp() {
  store = RecordStore.openRecordStore("testing", true);
}

public void tearDown() {
  RecoredStore.deleteRecordStore("testing");
}

public void testStore() {
  int id = store.addRecord(new byte[] {5, 6}, 0, 2);
  assertEquals(2, store.getRecordSize(id));
  byte[] buffer = new byte[2];
  assertEquals(2, store.getRecord(id, buffer, 0));
  assertEquals(5, buffer[0]);
  assertEquals(6, buffer[1]);
}
```

만약 우리가 API를 제대로 이해했다면 이 테스트는 한번에 통과할 것이다.

패키지의 새버전이 도착하면 우선 테스트를 실행하고 필요하다면 수정한다. 테스트가 통과되지 않으면 애플리케이션 역시 실행되지 않을것이기 때문에 애플리케이션을 실행해볼 필요도 없다. 테스트가 일단 통과한다면 애플리케이션은 항상 제대로 돌아갈 것이다.

### 또 다른 테스트

저자는 주제에서 벗어나지 않고 기술적인 논의를 계속할 수 있는 방법은 주제와 무관한 아이디어가 떠오르면 이에 대한 테스트를 할일 목록에 적어놓고 다시 주제로 돌아온다고 한다.

**대화를 엄격하게 한 주제로 묶는 것은 훌륭한 아이디어를 억압하는 최고의 방법이다.**

내가 가야 할 길을 놓치지 않는것이 때로는 최선이며, 새 아이디어가 떠오르면 존주하고 맞이하되 그것이 내 주의를 흩뜨리지 않게 한다. 그 아이디어를 리스트에 적어놓고는 하던 일로 다시 돌아간다.

### 회귀 테스트

시스템 장애가 보고될 때 그 장애로 인하여 실패하는 테스트, 그리고 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 가장 간단하게 작성하라.

회귀 테스트(regression test)란, 선견지명이 있다면 처음 코딩할 때 작성했어야 하는 테스트다.

애플리케이션 차원의 회귀 테스트는 시스템의 사용자들이 정확히 무엇을 기대했으며 무엇이 잘못되었는지 말할 기회를 준다. 좀 더 작은 차원의 회귀 테스트는 테스트를 개선하는 방법이 된다.

기괴할 정도로 큰 음수에 대한 결함 보고서는 테스트 목록을 작성할 때 정수 롤오버를 테스트할 필요가 있다는 것을 배울 수 있다.

시스템 장애를 손쉽게 격리시킬 수 없다면 리팩토링해야한다. 이런 종류의 장애가 있다는것은 시스템이 이렇게 말하는 것이다. `"아직 내 설계를 마무리 못했구먼."`

### 휴식

샤워를 하다보면 끙끙앓던 코딩의 실마리가 풀리는 경험이 있다. 당연히 그 반대의 경우도 생긴다.  
`"매개 변수를 뒤집은 상태에서 시도한 적은 없었지!"`

뭘 해야 할지 모르겠으면 샤워하러 가서 뭘 해야 할지 생각날때까지 계속 샤워를 한다.
**피로는 판단력에 음성적인 영향을 끼치고, 판단력은 다시 피로에 음성적인 영향을 끼친다.**

키보드로 뭘 쳐야할지 알면, 명백한 구현을 한다. 잘 모르겠다면 가짜 구현을 한다. 올바른 설계가 명확하지 않다면 삼각측량 기법을 사용한다. 그래도 모르겠으면 샤워나 하러 가는거다.

`피곤함의 고리에서 빠져 나가는 방법은 외부 요소를 도입하는 것`이다.

1. 시간단위: 물병을 키보드 옆에 두어서 생리 현상으로 규칙적인 휴식을 하도록 유도한다.
2. 하루단위: 더 진행하기 전에 잠이 필요한 경우 정규 근무 시간 후의 약속이 진행을 멈추는 데에 도움이 된다.
3. 주 단위: 의식적이고 에너지 소모적인 업무 관련 생각을 떨쳐버리는 데에 주말 활동이 도움이 된다.
4. 년 단위 : 강제 휴가 정책이 재충전을 완벽히 도와줄 것이다.

어려운 문제에 직면했을 때 계속 압박을 가해서 돌파해야 할 경우도 있지만 프로그램이 문화는 마초 정신에 심하게 길들여져 있다.  
"내 건강을 희생해서 가족도 멀리하고 목숨도 버릴 각오가 되었소!"  
이 분야 사람들에게 그리 권하고 싶지 않은 문화다.

### 다시 하기

길을 잃은 느낌이 들땐 코드를 다 지워버리고 처음부터 다시 하자.

완전히 꼬인것을 풀려고 하는 것은 바보 같은 프로그래밍 실수에 기반을 두고 그 틀안에서 해결하려고 하는 것이기 떄문이다.

### 싸구려 책상, 좋은 의자

1. 나머지 시설은 싸구려여도 의자는 좋은것으로 사자.
2. 개인이 이메일을 확인하거나 웹서핑을 할때 쓸 컴퓨터는 싼것으로 구매하고, 공용 개발을 위한 컴퓨터는 최고로 좋은것을 구입하라.

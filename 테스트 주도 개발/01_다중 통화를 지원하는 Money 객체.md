## 1장. 다중 통화를 지원하는 Money 객체

---

### TDD의 리듬

1. 재빨리 테스트를 하나 추가한다.
2. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
3. 코드를 조금 바꾼다.
4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
5. 리팩토링을 통해 중복을 제거한다.

### 다중통화를 지원하는 보고서

| 종목     | 주   | 가격   | 합계     |
| -------- | ---- | ------ | -------- |
| IBM      | 1000 | 25USD  | 25000USD |
| Novartis | 400  | 150CHF | 60000CHF |
|          |      | 합계   | 65000USD |

| 기준 | 변환 | 환율 |
| ---- | ---- | ---- |
| CHF  | USD  | 1.5  |

- 어떠한 테스트들이 있어야 제대로 계산되는 코드가 완성됐다는걸 확신할 수 있을까?
  - 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야한다.
  - 어떤 금액을 어떤 수에 곱한 금액을 결과로 얻을 수 있어야 한다.

```
$5 + 10 CHF = $10(환율이 2:1일 경우)
$5 * 2 = $10 ▶진행중
```

**테스트를 작성할 때 어떤일을 해야하는지, 언제 일이 다 끝내는지 알려주고, 지금 하는 일에 집중할 수 있게끔 도와주는 할일 목록을 작성한다.**

### 테스트의 시작

가능한 최선의 API에서 시작해서 거꾸로 작업하는 것이 애초부터 일을 복잡하고 보기 흉하며 `현실적`이게 하는 것보다 낫다.

#### 1. 간단한 곱셈부터

```java
public void testMultiplication() {
  Dollar five = new Dollar(5);
  five.times(2);
  assertEquals(10, five.amount);
}
```

**해당 코드의 문제점**

1. 공용 필드(public field)
2. 금액을 계산시 정수형을 사용
3. 예기치 못한 부작용(side effect) 존재

**<U>But</U>**
TDD는 작은 단계로부터 시작되는 것이다. 해당되는 문제를 실패하는 테스트를 만들고 이후에 최대한 빨리 초록막대를 보도록 하자.

```
$5 + 10 CHF = $10(환율이 2:1일 경우)
$5 * 2 = $10 ▶진행중
amount를 private로 만들기
Dollar 부작용(side effect)?
Money 반올림?
```

#### 2. 컴파일 에러

현재 네 개의 컴파일 에러가 있다.

1.  Dollar 클래스가 없음
2.  생성자가 없음
3.  times(int) 메서드가 없음
4.  amount 필드가 없음

<U>한번에 하나씩 아래처럼 정복한다.</U>

1.  Dollar 클래스가 없음.  
    → Dollar 클래스를 정의한다.
2.  생성자가 없음  
    → 생성자만 만든다. (컴파일만 되게 할거라 생성자 내부는 비운다)
3.  times(int) 메서드가 없음  
    → times()의 스텁 구현(껍데기 코드)을 한다.
4.  amount 필드가 없음  
    → 필드 추가

```java
public class Dollar {
    int amount;

    public Dollar(int amount) {
    }

    void times(int multiplier) {

    }
}
```

**테스트는 실패했다. (기대값: 10, 결과값: 0)**
실패한게 아니다. `다중 통화 구현` 에서 `이 테스트를 통과시킨 후 나머지 테스트들도 통과시키기`로 변형된 것이다.

**당장의 목표는 완벽한 해법을 구하는 것이 아니라 테스트를 통과하는 것 뿐이다.**

#### 3. 테스트만 통과시키자

기존 코드에서 `int amount = 10`으로 변경하여 값을 지정해 주면 당장 테스트는 통과한다.

이후 코드의 중복을 제거해야 한다.

- 의존성과 중복
  의존성이 문제 그 자체라면 중복(duplication)은 문제의 징후다.  
  중복된 로직을 하나로 끄집어내는 일엔 객체를 이용하는 것이 최고다.  
  프로그램에서는 중복만 제거해 주면 의존성도 제거된다.  
  이게 바로 TDD의 두 번째 규칙이 존재하는 이유다.  
  다음 테스트로 진행하기 전에 중복을 제거함으로써, 오직 한 가지(one and only one)[^one and only one]의 코드 수정을 통해 다음 테스트도 통과되게 만들 가능성을 최대화하는 것이다.

\[^one and only one]: 필요한 것을 하되(once) 단 한 번만(only once)하라는 뜻의 익스트림 프로그래밍 실천사항과 통한다

#### 4. 중복을 제거하자

**TDD의 핵심은 이런 작은 단계를 밟아야 한다는 것이 아니라, 이런 작은 단계를 밟을 능력을 갖추어야 한다는 것이다.**

1. 이번 경우에는 중복이 테스트에 있는 데이터와 코드에 있는 데이터 사이에 존재한다.  
   `int amount = 10` 은 우리 머릿속으로 곱셈을 수행한 값이다. `int amount = 5 * 2`로 변경한다.
2. 5와 2가 두곳에 존재하나 한번에 제거할 수 있는 방법은 없다. 하지만 객체의 초기화 단계에 있는 설정 코드를 times() 메서드 안으로 옮긴다.
3. 5는 생성자에서 넘어오는 값이니 생성자 안에서 amount 변수에 저장하고 times()에서 사용한다.
4. 인자 `multiplier`의 값이 2이므로, 2라는 상수를 이 인자로 대체한다.

**최종코드**

```java
public class Dollar {
    int amount;

    public Dollar(int amount) {
        this.amount = amount;
    }

    void times(int multiplier) {
        amount *= multiplier;
    }
}
```

```
$5 + 10 CHF = $10(환율이 2:1일 경우)
$5 * 2 = $10 ▶완료
amount를 private로 만들기
Dollar 부작용(side effect)?
Money 반올림?
```

#### 5. 현재까지의 작업상황

1. 우리가 알고있는 작업해야할 테스트 목록을 만들었다.
2. 오퍼레이션이 외부에서 보여줘야 하는 대로 코드로 표현했다.
3. JUnit에 대한 상세한 사항들은 잠시 무시하기로 했다.
4. 스텁 구현을 통해 테스트를 컴패일 했다.
5. 끔찍한 죄악을 범하여 테스트를 통과시켰다.
6. 돌아가는 코드에서 상수를 변수로 변경하며 점진적으로 일반화했다.
7. 새로운 할일들을 한번에 처리하는 대신 할일 목록에 추가하고 넘어갔다.
